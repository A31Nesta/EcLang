#pragma once

#include "classes/language.hpp"
#include <cstddef>
#include <string>
#include <vector>
namespace eclang::lexer {
    namespace type {
        /**
            The type of token. This makes it easy
            for the parser to easily determine if the
            grammar is correct.
        */
        enum Type {
            // Single character
            SCOPE_ENTER, // {
            SCOPE_EXIT, // }
            ASSIGN, // =
            PARENTHESIS_OPEN, // (
            PARENTHESIS_CLOSE, // )
            COMMA, // ,
            SEMICOLON, // ;

            KEYWORD, // Identified by Hash (#) (/#[a-ZA-Z_-]+/)
            CLASS, // Dependent on the language (/[a-zA-Z_][a-zA-Z_0-9]*/)
            ATTRIBUTE, // Dependent on the language (/[a-zA-Z_][a-zA-Z_0-9]*/) (UNUSED: Attributes are considered Identifiers. The parser will check if it's an attribute)
            IDENTIFIER, // Anything that is not a class or attribute (/[a-zA-Z_][a-zA-Z_0-9]*/)

            NUMBER, // Number, can be integer or decimal, signed or unsigned. (/-?[0-9]+(\.{0,1}[0-9]+){0,1}/)
            STRING, // Identified by quotes (") (/"(\\.|[^\\"])*"/)
            STRING_MD, // Identified by backticks (`) (/`(\\.|[^\\`])*`/)

            INVALID, // Generated by scanToken but should be ignored. Usually syntax errors
            IGNORED // This token should be ignored, it can be white space, comment...
        };
    }

    /**
        When reading a file, the file is broken down into tokens,
        which are composed of the original string (usually a word or symbol;
        in the case of Strings and Markdown strings this is the whole string)
        and its type
    */
    struct Token {
        type::Type type;
        std::string string;
        size_t line = 0;
        size_t column = 0;
    };

    // FUNCTIONS
    // ---------

    /**
        Reads the source code character by character and returns a list
        of tokens that the parser can understand.
    */
    extern std::vector<Token> tokenizeSource(std::string sourceCode, Language* lang);
}